# Approach

## Brute force

- Pick elements one by one from the first index and iterating throughout the remaining elements to check if element matches.
- If matched, return true.
- If no matches found return false.
- Used Nested Loop

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        
        for(int i=0;i<nums.length;i++){           // O(n)
            for(int j=i+1;j<=nums.length-1;j++){  //O(n)
                if(nums[i]==nums[j]){
                    return true;
                }
            }
        }        
            return false;
    } 
}

Time complexity: O(n^2) 
Result: Time Limit Execeeded
```

## Sorting approach - Question doesn't specify not to modify input array

- Sort the Array, iterate through the array and compare consecutive elements.
- If matched, return true.
- If no matches found return false.

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums); // O(nlogn)
        for(int i=0;i<nums.length-1;i++){ //O(n)
            if(nums[i]==nums[i+1]) return true;
        }
        return false;
    }
}
Time complexity: O(nlogn)
```

## Final Approach- Hashset

## Version 1- Size comparision

- Since, Set doesn't allow duplicate value.
- Store all the values into the set and check the size of set is same as the original array

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set=new HashSet<>();
        for(int num:nums){ //O(n)
            set.add(num); 
        }
        if(set.size()==nums.length) return false;
        return true;
    }
}
Time complexity: O(n) 
```

## Version 2- Early exit

- add() return boolean, since set doesn't allow duplicate, when an duplicate element gets added it retur ns false.
- If add() is false then return true.
- If no matches found return false.

 ```java
  class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set=new HashSet<>();
        for(int num:nums){
            if(!set.add(num)) return true;
        }
        return false;
    }
}
```
