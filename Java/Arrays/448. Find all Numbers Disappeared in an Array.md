# Approach

## HashSet Approach

- Adding all the numbers into a Set.
- Given that, nums[i] ranges form [1,n], Using contains() of set,iterating through the range [1,n]
- If the index not present in set,it will be added to the ArrayList. 

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        HashSet<Integer> data=new HashSet<>();
        for(int i=0;i<nums.length;i++){
            data.add(nums[i]);
        }
        ArrayList<Integer> res=new ArrayList<>();
        for(int i=1;i<=nums.length;i++){
            if(!data.contains(i)){
                res.add(i);
            }
        }
       return res;
    }
}
Time Complexity: O(n)
Space Complexity: O(n)
```

## Boolean Array Approach

- Create a boolean Array and Mark the index as true for elements present in the Given Array.
- Iterate through the range [1,n], check if the index present in boolean Array,
- If not, Add to ArrayList

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        boolean[] seen=new boolean[nums.length+1];
        ArrayList<Integer> res=new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            seen[nums[i]]=true;
        }

        for(int i=1;i<=nums.length;i++){
            if(!seen[i]){
                res.add(i);
            }
        }

        return res;
    }
}
Time Complexity: O(n)
Space Complexity: O(n)
```

## Without extra space

- Marking seen elements inside the array itself.
- If index i, mark nums[i-1] as negative. To avoid duplicate elements, check if the element is alreay negative.
- Iterate through nums and find the positive valued number's index and return index+1.

```java

```